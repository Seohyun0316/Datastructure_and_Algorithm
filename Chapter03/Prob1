def min_operations(N, M, positions):
    # 큐를 1부터 N까지의 원소로 초기화 (리스트 사용)
    queue = list(range(1, N+1))
    total_operations = 0

    for pos in positions:
        # 현재 큐에서 뽑아내려는 위치의 인덱스를 찾음
        idx = queue.index(pos)

        # 왼쪽으로 이동하는 경우와 오른쪽으로 이동하는 경우의 이동 횟수를 계산
        left_moves = idx
        right_moves = len(queue) - idx

        # 더 적은 이동 횟수를 선택하고 총 이동 횟수에 더함
        total_operations += min(left_moves, right_moves)

        # 실제로 큐를 이동시키고 첫 번째 원소를 제거
        if left_moves <= right_moves:
            # 왼쪽 이동: 리스트를 해당 위치까지 슬라이스하여 재배열
            queue = queue[left_moves:] + queue[:left_moves]
        else:
            # 오른쪽 이동: 리스트를 뒤에서부터 슬라이스하여 재배열
            queue = queue[-right_moves:] + queue[:-right_moves]
        
        # 첫 번째 원소를 제거 (뽑아냄)
        queue.pop(0)

    return total_operations

# 입력 받기
N, M = map(int, input().split())
positions = list(map(int, input().split()))

# 결과 출력
print(min_operations(N, M, positions))
